%learnConnectivity Learns connectivity maps over one or two regions
%   learnConnectivity estimates function connectivity maps from fMRI data,
%   as described in these two papers:
%
%   C. Baldassano, M.C. Iordan, D.M. Beck, L. Fei-Fei. "Voxel-Level
%   Functional Connectivity using Spatial Regularization." Neuroimage.
%   2012 Jul 28;63(3):1099-1106. doi: 10.1016/j.neuroimage.2012.07.046
%
%   C. Baldassano, M.C. Iordan, D.M. Beck, L. Fei-Fei. "Discovering
%   Voxel-Level Functional Connectivity Between Cortical Regions."
%   Machine Learning and Interpretation in Neuroimaging Workshop, Neural
%   Information Processing Systems (NIPS) 2012.
%
%   Please cite these papers if you publish results using this function.
%   Any comments, questions, or bug reports can be directed to
%   Chris Baldassano <chrisb33@cs.stanford.edu> <chrisbaldassano.com>
%
%   Using learnConnectivity in 'both' mode (described below) requires 
%   the CVX package to be installed. CVX can be downloaded for free from
%   http://cvxr.com/cvx/ (this function has been tested with CVX v1.22 and 
%   v2.0 beta).
%
%   This function has been tested on MATLAB versions 2010b, 2011a, 2011b,
%   and 2012a.
%
%
%
%   All function arguments are specified as property, value pairs. The
%   function has two main modes of operation:
%
%   learnConnectivity('type','one', ...)
%   In this mode, a connectivity map is learned over region 1 using the
%   mean timecourse from region 2 as the seed. The required inputs are:
%   adj1: adjacency matrix for region 1 (numvox1 x numvox1)
%   bold1: timecourses for region 1 (numvox1 x numTimepoints)
%   bold2: timecourses for region 2 (numvox2 x numTimepoints)
%   The smoothness parameter lambda can be selected by either:
%   a) passing in a value for lambda
%   b) automatically selecting a value for lambda using cross-validation.
%      In this case, a vector runLabels (1 x numTimepoints) must be
%      specified. During cross-validation, the test set will consist of all
%      timepoints labeled 1, then all those labeled 2, then all those
%      labeled 3, etc.
%   Optional parameters are:
%   lambdaVector: a row vector of all lambda values to try during
%                 cross-validation (default: logspace(-6,8,60))
%   zscore: a 0/1 flag specifying whether voxels should be normalized to
%           have standard deviation of 1 (default: 0)
%   quiet: a 0/1 flag specifying whether warnings and other output should
%          be suppressed (default: 0)
%
%   The return value is a column vector of length numvox1 giving the
%   relative connectivity strength for each voxel (weights may be positive
%   or negative). This connectivity map is computed using the closed-form
%   solution to the quadratic objective rather than CVX.
%
%
%
%
%   learnConnectivity('type','both', ...)
%   In this mode, connectivity maps are learned simultaneously over regions
%   1 and 2. The required inputs are:
%   adj1: adjacency matrix for region 1 (numvox1 x numvox1)
%   adj2: adjacency matrix for region 2 (numvox2 x numvox2)
%   bold1: timecourses for region 1 (numvox1 x numTimepoints)
%   bold2: timecourses for region 2 (numvox2 x numTimepoints)
%   lambda: smoothness parameter
%   Optional parameters are:
%   zscore: a 0/1 flag specifying whether voxels should be normalized to
%           have standard deviation of 1 (default: 0)
%   quiet: a 0/1 flag specifying whether warnings and other output should
%          be suppressed (default: 0)
%   numRestarts: number of initializations to try (default: 20)
%   trustTheta: constraint tolerance during optimization (default: 0.05)
%   trustDelta: trust radius during optimization (default: sqrt(0.05))
%   stepEpsilon: convergence criteria (default: sqrt(0.05)/100)
%   matchEpsilon: criteria for matching redundant solutions (default: 0.01)
%
%   The return value consists of two cells corresponding to regions 1 and
%   2. Each cell contains a matrix of size numvox x numSolutions, i.e.
%   connWeights{1}(:,i) and connWeights{2}(:,i) give the connectivity maps
%   over regions 1 and 2 for solution i. The connectivity weights are all
%   nonnegative.


% Copyright (c) 2014, Christopher Baldassano, Stanford University
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%     * Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of Stanford University nor the
%       names of its contributors may be used to endorse or promote products
%       derived from this software without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
% WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
% DISCLAIMED. IN NO EVENT SHALL CHRISTOPHER BALDASSANO BE LIABLE FOR ANY
% DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
% (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
% ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.